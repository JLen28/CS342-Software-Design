import java.util.Iterator;
import java.util.ListIterator;


public class GenericLinkedList<T> implements Iterable<T> {
	
	public class Node<T> { // Node class to be used for linked list...
		T data;
		Node<T> next;
		Node<T> prev;
		
	public Node(T val) { // Node constructor definition...
			data = val;
			next = null;
			prev = null;
			
		}
		
	}// end class Node definition...
	
	
	private Node<T> head = null; // GLL's head node declared...
	private int length = 0; // GLL's length of list declared...
	
	
	public  GenericLinkedList(T val) { // GLL constructor defined...
		head = new Node<>(val);
		head.next = null;
		head.prev = null;
		length++;
	}// end GLL constructor definition...
	
	
	public void addFirst(T e) {
		Node<T> nuNode = new Node<>(e); // create a new node with the data value of e...
		if(head == null) {
			head = nuNode;
			length++;
			return;
		}
		nuNode.next = head;// we set the new node to be in front of the current head...
		head.prev = nuNode; // we set the current head's previous node to be the new node...
		head = nuNode;// now the old head is preserved we can update the new node to be the current head...
		head.data = nuNode.data;
		length++; // incrementing the length to reflect an added node to the LL...
		
	}// end of addFirst definition...
	
	
	public void addLast(T e) { 
		Node<T> nuNode = new Node<>(e); // create a new node with the data value of e...
		if(head == null) {
			head = nuNode;
			length++;
			return;
		}
		if(head.next == null) { // check that the list has not been freshly generated..
			head.next = nuNode;// okay so fresh LL, add the new node to the end of the head..
			nuNode.prev = head;
			length++;
			return; // we've accomplished what we needed, no need to go further, return from method...
		}
		Node<T> traveller = this.head; // declaring a node that will "travel" through the LL starting at the head...
		while(traveller.next != null) { // while there is a next node..
			traveller = traveller.next;
			
		} // at this point we've found the end of the list...
		traveller.next = nuNode;// adding the new node to the end of the list...
		nuNode.prev = traveller;
		length++; // incrementing the length to reflect and added node to the LL...
	}// end of addLast definition...
	
	
	public boolean contains(T e) {
		Node<T> traveller = this.head;
		if(traveller.data == e) { // does the head's data value match what we're looking for?
			return true; // yes so return true...
		}
		while (traveller.next != null ) {
			traveller = traveller.next;
			if(traveller.data == e) { // does the data at the particular node match what we're looking for?
				return true; // yes so return true...
			}
		}// if we got here, we haven't found what we're looking for, return false...
		return false;// not contained in the LL, return false...
	}// end of contains function...
	
	
	public boolean remove(T e) {
		if ( head == null) { // initial check too see if the list is empty, if it is, then everything is removed so return false...
			return false;
		}
		Node<T> traveller = this.head; // our temp node to traverse the LL...
		if(e == traveller.data) { // here we check if the head node is our match, if it is, we need to check two possible cases...
			if(traveller.next == null) {//case 1: the head node is the only node in the list, and should then be deleted to make the list empty...
				head = null;
				length--;
				return true;
			}
			else {// case 2: the head node has a node to the next of it, so we must update the head to reflect the removed node...
				head = traveller.next;
				length--;
				return true;
			}
		}// at this point in the method we've determined the match is not the head node...
		while(traveller.next != null) {//traversing the LL with our temp...
			traveller = traveller.next;
			if(traveller.next != null) {// this if statement handles the case of a node that needs to be removed that is sandwiched between a prev and next...
				traveller.prev.next = traveller.next; // attach node to be removed's prev to its next...
				traveller.next.prev = traveller.prev; // attach node to be removed's next to its prev...
				traveller = null;// freeing up traveller....
				length--;
				return true;
			}
		}// at this point in the method we've determined that either the node to be removed is the last node or not in the LL...
		if(traveller.data == e) {// checking to see if the last node in the LL is our match...
			traveller.prev.next = null; // snipping off the node at the end, and updating the tail...
			length--;
			return true;
		}
		return false; // the desired node is not in the LL, return false...
	}// end of remove definition...
	
	
	public void clear() { // with the remove function already implemented, clear can be written with ease...
		if(head == null) { // checking if the list is empty as we do not need to clear an empty list...
			return;
		}
		else if(head.next == null) { // next edge case is there is only one node in the list...
			head = null; // if there is only one node, it is the head, so set head to null and decrease the length...
			length--;
			return;
		}
		else {
			while(head.next != null) { // traversing the list using head, as we are going to clear everything anyways...
				remove(head.data); // utilizing our remove function to simplify the function...
				head = head.next; // re-assigning head to traverse the list...
			}
			remove(head.data); // one more remove to assure all has been cleaned up...
			length = 0; // reset the length...
		}
	}// end of clear definition....
	
	
	public T get(int index) { // get returns a node from a specified index of the LL and returns null when the index exceeds the LL's length...
		int i = 0; // setting up our traverser for the loop and index..
		Node<T> traveller = head; // setting up our Node to walk down the list...
		if(index > length || index < 0) { // if the index is greater than the length or less than zero, then we know it is out of bounds, so return null...
			return null;
		}
		for( i = 0; i < index; i++) { // traversing to the specified index...
			traveller = traveller.next; // traversing through the list...
		}
		return traveller.data; // return the data of the specified node...
	}
	
	public T set(int index,T element) {// set returns the old value of a modified element of the LL which has now been updated with the specified element...
		int i = 0; // setting up our traverser for the loop and index...
		T oldVal; // field to hold the old element's value;
		Node<T> traveller = head; // setting up Node to walk down the list...
		if(index > length || index < 0) { // if the index is greater than the length or less than zero, then we know it is out of bounds, so return null...
			return null;
		}
		if(index == 0) { // if the particular index is the head, we can handle that now...
			oldVal = head.data;
			head.data = element;
			return oldVal;
		}
		for(i = 0; i < index; i++) { // traversing to the specified index...
			traveller = traveller.next; // traversing through the list...
		}
		oldVal = traveller.data;
		traveller.data = element;
		return oldVal;

	}
	
	public T removeHead() { // method removes the head from the list and updates it if necessary...
		T val;
		if(head == null) { // empty list means no head to be removed, return null...
			return null;
		}
		val = head.data; // store the data of the head to be deleted...
		if(head.next == null) { // if the head has no next then it is the only node in the list, so just delete it...
			head = null;
			length--;
			return val;
		}
		head = head.next; // if there is a next, simply update the head to reflect the head removal from the list...
		length--;
		return val;
	}
	
	public T removeTail() { // method removes the tail from the list and updates it if necessary..
		T val;
		if(head == null) { // empty list means no tail to be removed, return null...
			return null;
		}
		Node<T> traveller = head; // we need to walk down to the end of the list so a temp node will be necessary...
		while(traveller.next != null)
		{
			traveller = traveller.next; // traversing down the list...
		}
		val = traveller.data; // storing the data of the tail to be deleted...
		if(traveller.prev == null) { // if the previous is null, that means the node is the head, and we have 2 cases to account for...
			head = null;
			length--;
			return val;
		}
		else {
			
			traveller.prev.next = null;
			length--;
			return val;
		}
		
	}
	
	
	public  T getHeadData() { // function that returns the data valued stored at head...
		
		return head.data;
		
	}// end of getHead definition...
	
	public Node<T> getHead() {
		return head;
	}
	
	public  T getHeadNext() { // function that returns the data valued stored at head...
		
		return head.next.data;
		
	}// end of getHead definition...
	
	
	public int size() { // method returns the current length of the LL...
		return this.length;
	}// end of size definition...
	
	
	public T getTailData() { // method returns the tail of the LL...
		Node<T> traveller = this.head; // node to "travel" through the LL... 
		while(traveller.next != null) {// while there is a next node...
			traveller = traveller.next;
		}// at this point we've found the end of the list...
		return traveller.data;// return the data member stored at the tail end of the LL...
	}// end of getTail definition...
	
	public Node<T> getTail() { // method returns the tail of the LL...
		Node<T> traveller = this.head; // node to "travel" through the LL... 
		while(traveller.next != null) {// while there is a next node...
			traveller = traveller.next;
		}// at this point we've found the end of the list...
		return traveller;// return the data member stored at the tail end of the LL...
	}// end of getTail definition...
	
	
	

	
	public Iterator<T> iterator() {
		
		return new GLLIterator<>(this);
	}
	
	
	public Iterator<T> descendingiterator(){
		return new ReverseGLLIterator<>(this);
	}
	
	public ListIterator<T> listIterator(int index) {
		if(index > length || index < 0) {
			return null;
		}
		return new GLListIterator<>(this,index,length);
	}	

}// END OF LL CLASS...